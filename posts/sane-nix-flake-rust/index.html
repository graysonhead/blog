<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    

    
    <title>
         Nix Powered Dev Environments: Rust
        
    </title>

    
    <meta property="og:title"
        content="Nix Powered Dev Environments: Rust" />
    
    

    
    
    

    
    
    

    

    

    

    
    
    <script src=https://blog.graysonhead.net/js/feather.min.js></script>
    


    
    <link href=https://blog.graysonhead.net/css/fonts.css rel="stylesheet" />
    

    <link rel="stylesheet" type="text/css" media="screen" href=https://blog.graysonhead.net/css/main.css />

    
    <link rel="stylesheet" id="darkModeStyle" type="text/css" href=https://blog.graysonhead.net/css/dark.css   />
    


    


</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CCTJX63WS9"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-CCTJX63WS9');
</script>

<body>
    <div class="content">
        <header>
    <div class="main" id="main_title">
        <a href=https:&#x2F;&#x2F;blog.graysonhead.net></a>
    </div>

    <nav>
        
            <a href=&#x2F;posts>&#x2F;posts</a>
        
            <a href=&#x2F;projects>&#x2F;projects</a>
        
            <a href=&#x2F;about>&#x2F;about</a>
        

        
            |

            
                <a href=&#x2F;>en</a>
            
        

        
    </nav>
</header>


        
    
<main>
    <article>
        <div class="title">
            <h1 class="title">Nix Powered Dev Environments: Rust</h1>
            <div class="meta">
                
                on  2023-04-24

                
            </div>
        </div>

        

        <section class="body">
            <p>Nix is not just a language, package manager, or operating system, but an ecosystem with remarkable capabilities. </p>
<p>This tutorial is targeted for someone who is getting their feet wet with Nix, using the Nix
package manager on Linux or MacOS. But, it also demonstrates a development workflow
that can be used by other crazy people like me that daily drive NixOS.</p>
<p>I started using Nix about a year and a half ago, and since then I've 
gone deep down the rabbit hole. To the point where my entire home setup runs 
NixOS primarily. Having a consistent experience across all
of my computers is a wonderful thing, and one of the best parts is 
having truly 100% isolated development environments. </p>
<p>While bootstrapping these is a bit more work, (due to an intentional complete 
lack of development tools in my system path), having near 
guaranteed isolation between projects is 
quite an incredible thing.</p>
<p>The core components of this development workflow center around <a href="https://nixos.wiki/wiki/Flakes">Nix Flakes</a> and <a href="https://direnv.net/">Direnv</a>.</p>
<h1 id="flake-templates">Flake Templates</h1>
<p>Due to the increased initial cost of setting up a new project, its almost mandatory to 
create standardized Flake templates to save yourself time when kickstarting a new project.</p>
<p>I maintain a repo of <a href="https://github.com/graysonhead/nix-templates">Flake Templates</a> customized for my use, but they are MIT licensed so feel free to use them.</p>
<p>Today we are going to explore the Rust templates that I still actively use.</p>
<h1 id="simple-naersk-nixpkgs">Simple: Naersk + Nixpkgs</h1>
<p>Here is a simple, but useful, Rust Flake example:</p>
<pre data-lang="nix" style="background-color:#2b303b;color:#c0c5ce;" class="language-nix "><code class="language-nix" data-lang="nix"><span>{
</span><span>  </span><span style="color:#65737e;"># This is our input set, it contains the channels we will construct the flake from.
</span><span>  </span><span style="color:#d08770;">inputs </span><span>= {
</span><span>    </span><span style="color:#65737e;"># Flake-utils allows us to easily support multiple architectures.
</span><span>    </span><span style="color:#d08770;">flake-utils</span><span>.</span><span style="color:#d08770;">url </span><span>= &quot;</span><span style="color:#a3be8c;">github:numtide/flake-utils</span><span>&quot;;
</span><span>    </span><span style="color:#65737e;"># Naersk is a zero-configuration zero-codegen solution to packaging Rust.
</span><span>    </span><span style="color:#d08770;">naersk</span><span>.</span><span style="color:#d08770;">url </span><span>= &quot;</span><span style="color:#a3be8c;">github:nix-community/naersk</span><span>&quot;;
</span><span>    </span><span style="color:#65737e;"># Nixpkgs is the main package repo for Nix, we will use it to bring in all of our
</span><span>    </span><span style="color:#65737e;"># libraries and tools.
</span><span>    </span><span style="color:#d08770;">nixpkgs</span><span>.</span><span style="color:#d08770;">url </span><span>= &quot;</span><span style="color:#a3be8c;">github:NixOS/nixpkgs/nixpkgs-unstable</span><span>&quot;;
</span><span>  };
</span><span>
</span><span>  </span><span style="color:#65737e;"># This is the output set, Nix and other Flakes will be able to consume the attributes
</span><span>  </span><span style="color:#65737e;"># in the output set.
</span><span>  </span><span style="color:#d08770;">outputs </span><span>= </span><span style="color:#8fa1b3;">{ </span><span>self, flake-utils, naersk, nixpkgs </span><span style="color:#8fa1b3;">}</span><span>:
</span><span>    </span><span style="color:#65737e;"># We wrap the entire output set in this flake-utils function, which builds the flake
</span><span>    </span><span style="color:#65737e;"># for each architecture type supported by nix.
</span><span>    </span><span style="color:#bf616a;">flake-utils</span><span>.</span><span style="color:#bf616a;">lib</span><span>.</span><span style="color:#bf616a;">eachDefaultSystem </span><span>(system:
</span><span>      </span><span style="color:#b48ead;">let
</span><span>        </span><span style="color:#65737e;"># This sets up nixpkgs, where we will pull our dependencies from
</span><span>        </span><span style="color:#d08770;">pkgs </span><span>= (</span><span style="color:#96b5b4;">import </span><span style="color:#bf616a;">nixpkgs</span><span>) {
</span><span>          </span><span style="color:#65737e;"># You can insert overlays here by calling `inherit system overlays;` 
</span><span>          </span><span style="color:#b48ead;">inherit </span><span style="color:#d08770;">system</span><span>;
</span><span>        };
</span><span>
</span><span>        </span><span style="color:#65737e;"># This sets up naersk, which we will use later.
</span><span>        </span><span style="color:#d08770;">naersk&#39; </span><span>= </span><span style="color:#bf616a;">pkgs</span><span>.</span><span style="color:#bf616a;">callPackage naersk </span><span>{ };
</span><span>
</span><span>        </span><span style="color:#65737e;"># Here we can add non-rust dependencies that our program requires *at run time*.
</span><span>        </span><span style="color:#d08770;">buildInputs </span><span>= </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">pkgs</span><span>; [
</span><span>
</span><span>        ];
</span><span>
</span><span>        </span><span style="color:#65737e;"># here we can add non-rust dependencies that our program requires *at build time*.
</span><span>        </span><span style="color:#d08770;">nativeBuildInputs </span><span>= </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">pkgs</span><span>; [
</span><span>
</span><span>        ];
</span><span>      </span><span style="color:#b48ead;">in
</span><span>      </span><span style="color:#b48ead;">rec </span><span>{
</span><span>        </span><span style="color:#65737e;"># Build this with `nix build`, run it with `nix run`
</span><span>        </span><span style="color:#d08770;">defaultPackage </span><span>= </span><span style="color:#bf616a;">packages</span><span>.</span><span style="color:#bf616a;">app</span><span>;
</span><span>        </span><span style="color:#d08770;">packages </span><span>=
</span><span>          {
</span><span>            </span><span style="color:#d08770;">app </span><span>= </span><span style="color:#bf616a;">naersk&#39;</span><span>.</span><span style="color:#bf616a;">buildPackage </span><span>{
</span><span>              </span><span style="color:#65737e;"># Naersk will look for a `Cargo.toml` in this directory
</span><span>              </span><span style="color:#d08770;">src </span><span>= </span><span style="color:#a3be8c;">./.</span><span>;
</span><span>              </span><span style="color:#65737e;"># Our buildinputs from above are specified here
</span><span>              </span><span style="color:#d08770;">nativeBuildInputs </span><span>= </span><span style="color:#bf616a;">nativeBuildInputs</span><span>;
</span><span>              </span><span style="color:#d08770;">buildInputs </span><span>= </span><span style="color:#bf616a;">buildInputs</span><span>;
</span><span>            };
</span><span>            </span><span style="color:#d08770;">contianer </span><span>= </span><span style="color:#bf616a;">pkgs</span><span>.</span><span style="color:#bf616a;">dockerTools</span><span>.</span><span style="color:#bf616a;">buildImage
</span><span>              {
</span><span>                </span><span style="color:#d08770;">name </span><span>= &quot;</span><span style="color:#a3be8c;">app</span><span>&quot;;
</span><span>                </span><span style="color:#d08770;">config </span><span>= {
</span><span>                  </span><span style="color:#d08770;">entrypoint </span><span>= [ &quot;</span><span style="font-style:italic;color:#ab7967;">${</span><span style="font-style:italic;color:#bf616a;">packages</span><span style="font-style:italic;color:#c0c5ce;">.</span><span style="font-style:italic;color:#bf616a;">app</span><span style="font-style:italic;color:#ab7967;">}</span><span style="color:#a3be8c;">/bin/app</span><span>&quot; ];
</span><span>                };
</span><span>              };
</span><span>          };
</span><span>
</span><span>        </span><span style="color:#65737e;"># This will be entered by direnv, or by manually running `nix shell`. This ensures
</span><span>        </span><span style="color:#65737e;"># that our development environment will have all the correct tools at the correct
</span><span>        </span><span style="color:#65737e;"># version for this project.
</span><span>        </span><span style="color:#d08770;">devShell </span><span>= </span><span style="color:#bf616a;">pkgs</span><span>.</span><span style="color:#bf616a;">mkShell </span><span>{
</span><span>          </span><span style="color:#65737e;"># Here we add any tools that we want in our dev-shell but aren&#39;t required to build
</span><span>          </span><span style="color:#65737e;"># our application.
</span><span>          </span><span style="color:#d08770;">nativeBuildInputs </span><span>= </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">pkgs</span><span>;
</span><span>            [
</span><span>              </span><span style="color:#bf616a;">nixpkgs-fmt
</span><span>              </span><span style="color:#bf616a;">cmake
</span><span>              </span><span style="color:#bf616a;">rustc
</span><span>              </span><span style="color:#bf616a;">cargo
</span><span>              </span><span style="color:#bf616a;">clippy
</span><span>            ] ++ </span><span style="color:#bf616a;">buildInputs </span><span>++ </span><span style="color:#bf616a;">nativeBuildInputs</span><span>;
</span><span>          </span><span style="color:#65737e;"># The above line merges our buildInputs into the devshell, so we have them when
</span><span>          </span><span style="color:#65737e;"># using cargo tools from inside our devshell.
</span><span>        };
</span><span>      }
</span><span>    );
</span><span>}
</span><span>
</span></code></pre>
<p>You can setup this repo locally with this command:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>nix flake new --template github:graysonhead/nix-templates#rust-naersk ./changeme
</span></code></pre>
<p>This is the base template I use for any simple rust project I use that will be based off of
nixpgks and not require a nightly (or otherwise specific) build of Rust. Its a good starting
point, and it is already pretty flexible. For instance, if you are building something that
requires openssl you only need to change one line to add it:</p>
<pre data-lang="nix" style="background-color:#2b303b;color:#c0c5ce;" class="language-nix "><code class="language-nix" data-lang="nix"><span>{
</span><span>  </span><span style="color:#d08770;">buildInputs </span><span>= </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">pkgs</span><span>; [
</span><span>    </span><span style="color:#bf616a;">openssl
</span><span>  ];
</span><span>}
</span></code></pre>
<p>Using it is also simple. First, you shoud familiarize yourself with the output of <code>nix flake show</code>:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$ nix flake show
</span><span>git+file:///home/grayson/RustProjects/naersk-template
</span><span>├───defaultPackage
</span><span>│   ├───aarch64-darwin: package &#39;naersk-template-0.1.0&#39;
</span><span>│   ├───aarch64-linux: package &#39;naersk-template-0.1.0&#39;
</span><span>│   ├───x86_64-darwin: package &#39;naersk-template-0.1.0&#39;
</span><span>│   └───x86_64-linux: package &#39;naersk-template-0.1.0&#39;
</span><span>└───devShell
</span><span>    ├───aarch64-darwin: development environment &#39;nix-shell&#39;
</span><span>    ├───aarch64-linux: development environment &#39;nix-shell&#39;
</span><span>    ├───x86_64-darwin: development environment &#39;nix-shell&#39;
</span><span>    └───x86_64-linux: development environment &#39;nix-shell&#39;
</span><span>
</span></code></pre>
<p>Here we can see a tree of the output set (the set that the nix flake returns) in a more visually appealing form. This command is 
extremely useful on more complex flakes with dozens or even hundreds of outputs, but here it gives us a good idea of what is going on.</p>
<p>First, notice that both our <code>defaultPackage</code> and <code>devShell</code> have outputs for each architecture already. This is a result of the 
<code>flake-utils.lib.eachDefaultSystem</code> function that we wrapped our output set in. It ensures that the flake is repeated for each system type.</p>
<p>As a result, our flake will work on Linux and MacOS on both x86 and ARM systems. Best of all, we got that functionality practically for free!</p>
<p>Since we defined a <code>defaultPackage</code>, we can build the application by running <code>nix build</code>, or run it with <code>nix run</code>. You can enter the development
shell with <code>nix develop</code>, which will allow you to compile your program with native tools such as <code>cargo</code> as well as <code>clippy</code>.</p>
<p>To target a specific output, you can simply trace down the tree to your desired output, and call <code>nix build</code> or <code>nix run</code> like this:
<code>nix run .#defaultPackage.x86_64-linux</code>, or whatever arch you are on.</p>
<h1 id="containers">Containers</h1>
<p>Another nice thing about Nix flakes, is that you can easily build 
docker containers without needing a fragile dockerfile. For instance, you can
modify the output set and add a seperate output for building a container image:</p>
<pre data-lang="nix" style="background-color:#2b303b;color:#c0c5ce;" class="language-nix "><code class="language-nix" data-lang="nix"><span>{
</span><span>    </span><span style="color:#d08770;">packages </span><span>=
</span><span>          {
</span><span>            </span><span style="color:#d08770;">app </span><span>= </span><span style="color:#bf616a;">naersk&#39;</span><span>.</span><span style="color:#bf616a;">buildPackage </span><span>{
</span><span>              </span><span style="color:#65737e;"># Naersk will look for a `Cargo.toml` in this directory
</span><span>              </span><span style="color:#d08770;">src </span><span>= </span><span style="color:#a3be8c;">./.</span><span>;
</span><span>              </span><span style="color:#65737e;"># Our buildinputs from above are specified here
</span><span>              </span><span style="color:#d08770;">nativeBuildInputs </span><span>= </span><span style="color:#bf616a;">nativeBuildInputs</span><span>;
</span><span>              </span><span style="color:#d08770;">buildInputs </span><span>= </span><span style="color:#bf616a;">buildInputs</span><span>;
</span><span>            };
</span><span>            </span><span style="color:#d08770;">contianer </span><span>= </span><span style="color:#bf616a;">pkgs</span><span>.</span><span style="color:#bf616a;">dockerTools</span><span>.</span><span style="color:#bf616a;">buildImage
</span><span>              {
</span><span>                </span><span style="color:#d08770;">name </span><span>= &quot;</span><span style="color:#a3be8c;">app</span><span>&quot;;
</span><span>                </span><span style="color:#d08770;">config </span><span>= {
</span><span>                  </span><span style="color:#d08770;">entrypoint </span><span>= [ &quot;</span><span style="font-style:italic;color:#ab7967;">${</span><span style="font-style:italic;color:#bf616a;">packages</span><span style="font-style:italic;color:#c0c5ce;">.</span><span style="font-style:italic;color:#bf616a;">app</span><span style="font-style:italic;color:#ab7967;">}</span><span style="color:#a3be8c;">/bin/app</span><span>&quot; ];
</span><span>                };
</span><span>              };
</span><span>          };
</span><span>}
</span></code></pre>
<p>This allows you to build a container image by running <code>nix build .#container</code>, which
can be loaded into docker via <code>docker load -i ./result</code>. </p>
<h1 id="multi-workspace-projects">Multi-Workspace Projects</h1>
<p>Flakes also allow you to utilize workspaces as well, although the process for doing that 
in Naersk isn't exactly straightforward. </p>
<p>To build a project in a workspace, you can add this to your package output definition:</p>
<pre data-lang="nix" style="background-color:#2b303b;color:#c0c5ce;" class="language-nix "><code class="language-nix" data-lang="nix"><span>{
</span><span>  </span><span style="color:#d08770;">example-workspaced-app </span><span>= </span><span style="color:#bf616a;">naersk&#39;</span><span>.</span><span style="color:#bf616a;">buildPackage </span><span>{
</span><span>    </span><span style="color:#d08770;">name </span><span>= &quot;</span><span style="color:#a3be8c;">example-workspace</span><span>&quot;;
</span><span>    </span><span style="color:#d08770;">src </span><span>= </span><span style="color:#a3be8c;">./.</span><span>;
</span><span>    </span><span style="color:#d08770;">cargoBuildOptions </span><span>= x: </span><span style="color:#bf616a;">x </span><span>++ [ &quot;</span><span style="color:#a3be8c;">-p</span><span>&quot; &quot;</span><span style="color:#a3be8c;">example-workspace</span><span>&quot; ];
</span><span>  };
</span><span>}
</span></code></pre>
<p>This assumes that your workspace (with its own <code>Cargo.toml</code> file) is located in <code>./example-workspace</code>.</p>
<p>Note that you will also need to ensure that your main <code>Cargo.toml</code> file has an entry
for this workspace, like this:</p>
<pre data-lang="toml" style="background-color:#2b303b;color:#c0c5ce;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[workspace]
</span><span style="color:#bf616a;">members </span><span>= [
</span><span>    &quot;</span><span style="color:#a3be8c;">example-workspace</span><span>&quot;
</span><span>]
</span></code></pre>
<p>Cargo technically doesn't <em>need</em> this entry to function, but Naersk does, and you
won't be able to build or run anything in that workspace without it.</p>
<h1 id="nightly-rust">Nightly Rust</h1>
<p>If you want to use nightly rust (or a version seperate from Nixpkgs), you can use the <code>oxalica/rust-overlay</code>. </p>
<p>Here is a full example:</p>
<pre data-lang="nix" style="background-color:#2b303b;color:#c0c5ce;" class="language-nix "><code class="language-nix" data-lang="nix"><span>{
</span><span>  </span><span style="color:#d08770;">inputs </span><span>= {
</span><span>    </span><span style="color:#d08770;">flake-utils</span><span>.</span><span style="color:#d08770;">url </span><span>= &quot;</span><span style="color:#a3be8c;">github:numtide/flake-utils</span><span>&quot;;
</span><span>    </span><span style="color:#d08770;">naersk</span><span>.</span><span style="color:#d08770;">url </span><span>= &quot;</span><span style="color:#a3be8c;">github:nix-community/naersk</span><span>&quot;;
</span><span>    </span><span style="color:#d08770;">rust-overlay</span><span>.</span><span style="color:#d08770;">url </span><span>= &quot;</span><span style="color:#a3be8c;">github:oxalica/rust-overlay</span><span>&quot;;
</span><span>    </span><span style="color:#d08770;">nixpkgs</span><span>.</span><span style="color:#d08770;">url </span><span>= &quot;</span><span style="color:#a3be8c;">github:NixOS/nixpkgs/nixpkgs-unstable</span><span>&quot;;
</span><span>  };
</span><span>
</span><span>  </span><span style="color:#d08770;">outputs </span><span>= </span><span style="color:#8fa1b3;">{ </span><span>self, flake-utils, naersk, nixpkgs, rust-overlay </span><span style="color:#8fa1b3;">}</span><span>:
</span><span>    </span><span style="color:#bf616a;">flake-utils</span><span>.</span><span style="color:#bf616a;">lib</span><span>.</span><span style="color:#bf616a;">eachDefaultSystem </span><span>(system:
</span><span>      </span><span style="color:#b48ead;">let
</span><span>        </span><span style="color:#d08770;">overlays </span><span>= [ (</span><span style="color:#96b5b4;">import </span><span style="color:#bf616a;">rust-overlay</span><span>) ];
</span><span>        </span><span style="color:#d08770;">pkgs </span><span>= (</span><span style="color:#96b5b4;">import </span><span style="color:#bf616a;">nixpkgs</span><span>) {
</span><span>          </span><span style="color:#b48ead;">inherit </span><span style="color:#d08770;">system overlays</span><span>;
</span><span>        };
</span><span>
</span><span>        </span><span style="color:#d08770;">naersk&#39; </span><span>= </span><span style="color:#bf616a;">pkgs</span><span>.</span><span style="color:#bf616a;">callPackage naersk </span><span>{ };
</span><span>        </span><span style="color:#d08770;">buildInputs </span><span>= </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">pkgs</span><span>; [
</span><span>        ];
</span><span>        </span><span style="color:#d08770;">nativeBuildInputs </span><span>= </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">pkgs</span><span>; [
</span><span>          </span><span style="color:#65737e;"># This sets up the rust suite, automatically selecting the latest nightly version
</span><span>          (</span><span style="color:#bf616a;">rust-bin</span><span>.</span><span style="color:#bf616a;">selectLatestNightlyWith
</span><span>            (toolchain: </span><span style="color:#bf616a;">toolchain</span><span>.</span><span style="color:#bf616a;">default</span><span>.</span><span style="color:#bf616a;">override </span><span>{
</span><span>              </span><span style="color:#d08770;">extensions </span><span>= [ &quot;</span><span style="color:#a3be8c;">rust-src</span><span>&quot; &quot;</span><span style="color:#a3be8c;">clippy</span><span>&quot; ];
</span><span>            }))
</span><span>        ];
</span><span>      </span><span style="color:#b48ead;">in
</span><span>      </span><span style="color:#b48ead;">rec </span><span>{
</span><span>        </span><span style="color:#65737e;"># For `nix build` &amp; `nix run`:
</span><span>        </span><span style="color:#d08770;">defaultPackage </span><span>= </span><span style="color:#bf616a;">packages</span><span>.</span><span style="color:#bf616a;">naersk-nightly</span><span>;
</span><span>        </span><span style="color:#d08770;">packages </span><span>= </span><span style="color:#b48ead;">rec </span><span>{
</span><span>          </span><span style="color:#d08770;">naersk-nightly </span><span>= </span><span style="color:#bf616a;">naersk&#39;</span><span>.</span><span style="color:#bf616a;">buildPackage </span><span>{
</span><span>            </span><span style="color:#d08770;">src </span><span>= </span><span style="color:#a3be8c;">./.</span><span>;
</span><span>            </span><span style="color:#d08770;">nativeBuildInputs </span><span>= </span><span style="color:#bf616a;">nativeBuildInputs</span><span>;
</span><span>            </span><span style="color:#d08770;">buildInputs </span><span>= </span><span style="color:#bf616a;">buildInputs</span><span>;
</span><span>          };
</span><span>        };
</span><span>
</span><span>        </span><span style="color:#65737e;"># For `nix develop`:
</span><span>        </span><span style="color:#d08770;">devShell </span><span>= </span><span style="color:#bf616a;">pkgs</span><span>.</span><span style="color:#bf616a;">mkShell </span><span>{
</span><span>          </span><span style="color:#d08770;">nativeBuildInputs </span><span>= </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">pkgs</span><span>; [
</span><span>            </span><span style="color:#bf616a;">cargo-expand
</span><span>            </span><span style="color:#bf616a;">nixpkgs-fmt
</span><span>            </span><span style="color:#bf616a;">cmake
</span><span>          ] ++ </span><span style="color:#bf616a;">buildInputs </span><span>++ </span><span style="color:#bf616a;">nativeBuildInputs</span><span>;
</span><span>        };
</span><span>      }
</span><span>    );
</span><span>}
</span><span>
</span></code></pre>
<h1 id="making-development-shells-automatic">Making Development Shells Automatic</h1>
<p>Using <a href="https://direnv.net/">direnv</a>, and <a href="https://github.com/nix-community/nix-direnv">nix-direnv</a>, you can make the activation of your development
environment automatic. Add an <code>.envrc</code> file in the root of your repo with the line:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>use flake
</span></code></pre>
<p>And then run the command <code>direnv allow</code> from this directory. Your development shell will now be activated any time you change directory to that location.</p>
<p>This means that your entire environment will automatically switch whenever you change between projects, meaning you don't have to deal with rustup and
toolchains whenever you switch between a nightly and stable Rust project.</p>
<p>You can also get IDE/terminal editor plugins that allow you to use this environment as well, so that your <code>rust-analyzer</code> version is appropriate to the version
of Rust you are developing on. I use <code>cab404.vscode-direnv</code> for vscode, and <a href="https://github.com/direnv/direnv.vim">direnv-vim</a> for vim.</p>
<h1 id="bonus-round-nix-party-tricks">Bonus Round: Nix Party Tricks</h1>
<p>Lets look at some other fun stuff you can trivially do now that you have this set up. </p>
<p>Run a program from a remote git repo without permanently installing it in your profile or system path:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$ nix run github:nixos/nixpkgs/nixpkgs-unstable#hello
</span></code></pre>
<p>You can also cross-compile it to a different architecture (requires for <code>boot.binfmt.emulatedSystems</code> to be set appropriately on NixOS):</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$ nix build github:nixos/nixpkgs/nixpkgs-unstable#legacyPackages.aarch64-linux.hello
</span><span>$ file result/bin/hello 
</span><span>result/bin/hello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /nix/store/rjpx52ch4508wrq8wjf5nnbsc6pr3158-glibc-2.37-8/lib/ld-linux-aarch64.so.1, for GNU/Linux 3.10.0, not stripped
</span></code></pre>
<p>Need to distribute your program via RPM or Deb? In most cases, this is trivial:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$ nix bundle --bundler github:NixOS/bundlers#toDEB .#defaultPackage.x86_64-linux
</span><span>$ nix bundle --bundler github:NixOS/bundlers#toRPM .#defaultPackage.x86_64-linux
</span></code></pre>

        </section>

        
            <div class="post-tags">
                <nav class="nav tags">
                    <ul class="tags">
                        
                            <li><a href=https://blog.graysonhead.net/tags/tutorials/>Tutorials</a></li>
                        
                            <li><a href=https://blog.graysonhead.net/tags/nix/>Nix</a></li>
                        
                            <li><a href=https://blog.graysonhead.net/tags/nixos/>NixOS</a></li>
                        
                            <li><a href=https://blog.graysonhead.net/tags/rust/>Rust</a></li>
                        
                            <li><a href=https://blog.graysonhead.net/tags/rust-overlay/>rust-overlay</a></li>
                        
                            <li><a href=https://blog.graysonhead.net/tags/naersk/>naersk</a></li>
                        
                    </ul>
                </nav>
            </div>
        

    </article>
</main>



        <footer>
	<div style="display:flex">
	 
	     <a class="soc" href=https:&#x2F;&#x2F;github.com&#x2F;graysonhead title=GitHub>
	         <i data-feather=github></i>
	     </a>
	 
	     <a class="soc" href=https:&#x2F;&#x2F;hachyderm.io&#x2F;@Darkside title=Mastadon>
	         <i data-feather=globe></i>
	     </a>
	 
	     <a class="soc" href=https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;graysonhead&#x2F; title=LinkedIn>
	         <i data-feather=linkedin></i>
	     </a>
	 
	     <a class="soc" href=https:&#x2F;&#x2F;pixel.tchncs.de&#x2F;i&#x2F;web title=PixelFed>
	         <i data-feather=camera></i>
	     </a>
	 
	 </div>
	 <div class="footer-info">
	 2026 © Grayson Head
        </div>
</footer>


<script>
	    feather.replace();
</script>


    </div>
</body>

</html>
